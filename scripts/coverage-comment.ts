#!/usr/bin/env bun
// Generate coverage report comment for PR / PRìš© ì»¤ë²„ë¦¬ì§€ ë¦¬í¬íŠ¸ ëŒ“ê¸€ ìƒì„±
import { spawn } from "bun";
import { writeFileSync } from "fs";
import { join } from "path";

interface CoverageLine {
  file: string;
  funcs: number;
  lines: number;
  uncovered: string;
}

/**
 * Parse coverage output from bun test --coverage
 */
function parseCoverageOutput(output: string): {
  summary: { funcs: number; lines: number };
  files: CoverageLine[];
} {
  const lines = output.split("\n");
  const fileLines: CoverageLine[] = [];
  let summary = { funcs: 0, lines: 0 };

  // Find summary line
  const summaryLine = lines.find((line) => line.includes("All files"));
  if (summaryLine) {
    const match = summaryLine.match(/\|\s+(\d+\.\d+)\s+\|\s+(\d+\.\d+)\s+\|/);
    if (match) {
      summary = {
        funcs: parseFloat(match[1]),
        lines: parseFloat(match[2]),
      };
    }
  }

  // Parse file lines
  let inTable = false;
  for (const line of lines) {
    // Start parsing after table header
    if (line.includes("File") && line.includes("% Funcs")) {
      inTable = true;
      continue;
    }
    if (line.includes("---")) {
      continue;
    }
    if (!inTable) {
      continue;
    }

    if (line.includes("|") && !line.includes("All files")) {
      const parts = line
        .split("|")
        .map((p) => p.trim())
        .filter((p) => p);
      if (parts.length >= 3) {
        const file = parts[0];
        // Skip if it's a separator or header
        if (file === "File" || file.includes("---") || !file) {
          continue;
        }

        const funcs = parseFloat(parts[1]) || 0;
        const lines = parseFloat(parts[2]) || 0;
        const uncovered = parts[3] || "";

        // Skip test files
        if (!file.includes("__tests__") && !file.includes(".test.") && file.length > 0) {
          fileLines.push({
            file,
            funcs,
            lines,
            uncovered,
          });
        }
      }
    }
  }

  return { summary, files: fileLines };
}

/**
 * Format coverage as markdown comment / ì»¤ë²„ë¦¬ì§€ë¥¼ ë§ˆí¬ë‹¤ìš´ ëŒ“ê¸€ í˜•ì‹ìœ¼ë¡œ ë³€í™˜
 */
function formatCoverageComment(
  summary: { funcs: number; lines: number },
  files: CoverageLine[],
  packageName: string,
): string {
  const comment = `## ğŸ“Š Test Coverage Report - ${packageName}

### Summary

| Metric | Coverage |
|--------|----------|
| **Functions** | **${summary.funcs.toFixed(2)}%** |
| **Lines** | **${summary.lines.toFixed(2)}%** |

### File Coverage

<details>
<summary>Click to expand</summary>

| File | Functions | Lines | Uncovered Lines |
|------|-----------|-------|-----------------|
${files
  .sort((a, b) => b.lines - a.lines)
  .slice(0, 50)
  .map(
    (f) =>
      `| \`${f.file}\` | ${f.funcs.toFixed(2)}% | ${f.lines.toFixed(2)}% | ${f.uncovered || "N/A"} |`,
  )
  .join("\n")}

</details>

---

*Generated by test coverage script*
`;

  return comment;
}

/**
 * Run coverage test and generate comment for a single package
 */
async function generateCoverageComment(packagePath: string, packageName: string): Promise<string> {
  console.log(`Running coverage for ${packageName}...`);

  const proc = spawn({
    cmd: ["bun", "test", packagePath, "--coverage"],
    stdout: "pipe",
    stderr: "pipe",
    cwd: process.cwd(),
  });

  const output = await new Response(proc.stdout).text();
  const error = await new Response(proc.stderr).text();

  if (error && !error.includes("File")) {
    console.error(`Error running coverage:`, error);
  }

  const { summary, files } = parseCoverageOutput(output + error);
  return formatCoverageComment(summary, files, packageName);
}

/**
 * Main function / ë©”ì¸ í•¨ìˆ˜
 */
async function main() {
  const packagePath = process.argv[2];
  const packageName = process.argv[3] || "Package";

  if (!packagePath) {
    console.error("Usage: bun scripts/coverage-comment.ts <package-path> [package-name]");
    process.exit(1);
  }

  try {
    const comment = await generateCoverageComment(packagePath, packageName);

    const outputPath = join(process.cwd(), "coverage-comment.md");
    writeFileSync(outputPath, comment, "utf-8");

    console.log(`\nâœ… Coverage comment generated: ${outputPath}`);
    console.log("\n" + comment);
  } catch (error) {
    console.error(`Failed to generate coverage for ${packageName}:`, error);
    process.exit(1);
  }
}

if (import.meta.main) {
  main().catch(console.error);
}
