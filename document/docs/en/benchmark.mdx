# Benchmark

import { Benchmark } from "demo";

We **measure each library independently** with the same data and column schema for a fair execution-time comparison.

## What we compare

|           | react-wasm-table                            | @tanstack/react-table         |
| --------- | ------------------------------------------- | ----------------------------- |
| Rendering | Canvas (WASM)                               | DOM + @tanstack/react-virtual |
| Rows      | Full dataset in memory, virtualized by core | Virtualized rows in DOM       |
| Same data | ✓ `generateEmployees(N)`                    | ✓ Same                        |

## How it works

1. Generate the same `generateEmployees(N)` data.
2. Mount **only react-wasm-table** and measure time to first paint.
3. Unmount, wait 200ms, then mount **only @tanstack/react-table** and measure the same way.
4. Display results in a comparison table and bar chart.

## Run the benchmark

Click a row-count button (1K–100K) or **Run All** to benchmark every row count sequentially. After measurement, both grids appear side by side so you can also compare scroll performance.

<Benchmark />

## Why it's fast

- **Canvas** — No DOM nodes per cell; one canvas draws all visible content.
- **Rust/WASM** — Layout (Taffy), hit-testing, and scroll math run in WebAssembly.
- **Virtualization** — Only visible rows are laid out and drawn; the rest stay in JS memory.
